<!DOCTYPE html>
<html>
<head>
    <title>å£°æ§å°çƒæ—©è¯»æ¸¸æˆ</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #F0F4F8;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        #gameCanvas {
            background: linear-gradient(180deg, #E3F2FD 0%, #BBDEFB 100%);
        }
        #instruction {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255,255,255,0.9);
            padding: 15px 30px;
            border-radius: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            color: #2C3E50;
            font-weight: 500;
        }
    </style>
</head>
<body>
    <div id="instruction">å¤§å£°æœ—è¯»è®©å°çƒè·³èµ·æ¥å§ï¼ğŸ‰</div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let isMicReady = false;

        // è®¾ç½®ç”»å¸ƒå°ºå¯¸
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            baseY = canvas.height * 0.75; // åº•éƒ¨å››åˆ†ä¹‹ä¸€å¤„
        }
        
        class Ball {
            constructor() {
                this.radius = 8 + Math.random()*16;
                this.mass = this.radius * 0.8;
                this.color = `hsl(${Math.random()*360}, 70%, 60%)`;
                this.x = canvas.width/2 + (Math.random() - 0.5) * 300;
                this.y = window.innerHeight * 0.75 - this.radius;
                this.vy = 0;
                this.isResting = true;  // åˆå§‹çŠ¶æ€è®¾ä¸ºé™æ­¢
            }

            update(force) {
                if (force < 0) {
                    this.isResting = false;
                }

                if (!this.isResting) {
                    this.vy += force / this.mass;
                    this.vy += 0.8;
                    this.y += this.vy;

                    // æ·»åŠ é¡¶éƒ¨è¾¹ç•Œæ£€æµ‹
                    if (this.y < this.radius) {  // ç¢°åˆ°é¡¶éƒ¨
                        this.y = this.radius;
                        this.vy = Math.abs(this.vy) * 0.5;  // åå‘å¼¹å›
                    }

                    // åº•éƒ¨è¾¹ç•Œæ£€æµ‹
                    if (this.y > baseY - this.radius) {
                        this.y = baseY - this.radius;
                        this.vy *= -0.5;
                        
                        if (Math.abs(this.vy) < 1) {
                            this.isResting = true;
                            this.vy = 0;
                        }
                    }
                }
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.closePath();
            }
        }

        // ä¿®æ”¹åˆå§‹åŒ–é¡ºåº
        resizeCanvas();  // å…ˆè®¾ç½®ç”»å¸ƒå°ºå¯¸å’ŒbaseY
        const balls = Array.from({length: 290}, () => new Ball());  // ä»30æ”¹ä¸º90
        window.addEventListener('resize', resizeCanvas);

        // éŸ³é¢‘å¤„ç†
        let audioContext, analyser, microphone;
        async function initAudio() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: false,
                        autoGainControl: false
                    } 
                });
                audioContext = new AudioContext();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;  // å‡å°FFTå¤§å°ä»¥è·å¾—æ›´å¿«çš„å“åº”
                analyser.smoothingTimeConstant = 0.4;  // å¹³æ»‘å¤„ç†
                microphone = audioContext.createMediaStreamSource(stream);
                microphone.connect(analyser);
                isMicReady = true;
            } catch (err) {
                alert('éœ€è¦éº¦å…‹é£æƒé™æ‰èƒ½ç©æ¸¸æˆå“¦ï¼ğŸ¤');
                console.error(err);
            }
        }

        // ä¸»å¾ªç¯
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (isMicReady) {
                const dataArray = new Uint8Array(analyser.frequencyBinCount);
                analyser.getByteFrequencyData(dataArray);
                
                let volume = 0;
                for(let i = 0; i < dataArray.length; i++) {
                    volume += dataArray[i];
                }
                volume = volume / dataArray.length;
                
                // é™åˆ¶æœ€å¤§åŠ›çš„å¤§å°
                let force = 0;
                if (volume > 20) {
                    force = Math.max(-25, -(volume * 0.3));  // é™åˆ¶æœ€å¤§åŠ›
                }

                balls.forEach(ball => {
                    ball.update(force);
                    ball.draw();
                });
            }
            requestAnimationFrame(animate);
        }

        initAudio();
        animate();
    </script>
</body>
</html>